---
layout: post
title:  "JVM学习笔记3：类加载"
date:   2019-4-16 10:38:00 +0800
thumbnail: "img/home-bg-o.jpg"
categories: 
- 编程语言
tags: 
- Java
---

## 知识点

- 基本步骤：经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。
- 引用类型与CLR基本一致，泛型会被编译为特定类型的代码。类和接口是字节码。数组类是由 Java 虚拟机直接生成的，这个似乎没有CLR中对标的东西。
- 加载用的字节流可以来自java编译后的class，也可以是网络比如网页中内嵌的小程序 Java applet。字节流我理解就是IL，而且从结果看也确实就是这个东西。

<!--more-->

## 结论

- 加载器通加载字节流创建类
- 链接过程是把类合并到JVM，验证和准备是必须的，解析不是必须的。解析是一个符号引用到对象引用的转换过程。
- 初始化只执行一次，干两件事：
    - 常来字段赋值
    - 调用clinit函数

## 加载
- 通过类加载器来查找字节流

> 启动类加载器（boot class loader）：启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。
>
> 除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。
>
> 双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。

- C++启动一个java的加载器，然后java内部开始自加载，没毛病。

> 在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加载器（application class loader），均由 Java 核心类库提供。
>
> 扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。
> 
> 应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。
>
> Java 9 引入了模块系统，并且略微更改了上述的类加载器1。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。

- 支持自定义的类加载器

> 在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。

- opps!

## 链接
- 是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。
- 验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。
- 准备阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。
- 除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。
- 当一个class文件没有被加载到JVM之前，使用它其中内容的字节码实际使用的是一个符号引用，这个是有编译器生成的，包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。
- **解析阶段正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）**
- Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。

## 初始化
- 在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。
- 如果直接赋值的静态字段被 final所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），是虚拟机来初始化。其它的静态变量是一个名为clinit的函数来初始化。
- 类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。Java 虚拟机会通过加锁来确保类的 < clinit > 方法仅被执行一次。
- 类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：
    - 当虚拟机启动时，初始化用户指定的主类；
    - 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
    - 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
    - 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
    - 子类的初始化会触发父类的初始化；
    - 如果一个接口定义了 default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
    - 使用反射 API 对某个类进行反射调用时，初始化这个类；
    - 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。