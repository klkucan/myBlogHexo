---
layout: post
title:  "计算机组成原理：5、主存储器"
date:   2018-9-30 13:59:00 +0800
thumbnail: "img/home-bg-o.jpg"
categories: 
- 计算机基础
tags:
- 组成原理
---

### 一、概述

#### 1、基本构成

![主存构成](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%BB%E5%AD%98%E7%BB%93%E6%9E%84.png?raw=true)

- 结合上图总结一下之前的数据读取的操作
    - CPU在第一个时钟周期时通过地址总线发出要取数据的地址，这个地址是指的存储单元的地址。
    - MAR收到后，经过译码器得到指定的存储单元。
    - CPU在第二个时钟周期时通过控制总线讲读指令发送到主存储器
    - 控制电路根据信令来操作读写电路
    - 将之前得到主存储器地址中的数据写入MDR
    - 通过数据总线讲MDR中的数据送入到IR或者ACC

<!--more-->

#### 2、主存与CPU之间的联系

![CPU-主存](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/CPU-%E4%B8%BB%E5%AD%98.png?raw=true)

- CPU和主存之间主要是三个总线：地址、数据、命令
- 数据总线是双向的，而地址是单向

#### 3、主存中存储单元地址的分配

![存储单元地址分配](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png?raw=true)

- 数据在存储器中存储主要有两个方式，大端和小端。
- 图中高位字节指的是0x12345678中的12，其中从左到右为从高高低
- 但是在存储器中，地址小的为低位
- 所以大端中就是高位的12存在了低位，小端就是低位的78存在了低位。
- 关于按字节寻址和按字寻址详见延展阅读，

### 二、半导体存储芯片

#### 1、基本结构

![半导体存储芯片结构](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%BB%93%E6%9E%84.png?raw=true)

- 芯片容量计算：2^(地址线数量) * 数据线带宽，e.g 地址线10跟，数据线 4bit，那么容量就是 2^10 * 4 = 1k * 4bit
- 片选线：
    - 片选线的作用是来标记一次数据存储过程中，数据是否存在于一个存储芯片中。
    - 两周标识方式:CS\CE，上面的线表示低电平。也就是说如果管脚是低电平就说明这次要访问的是这个芯片。
    - 比如内存条上有很多存储芯片，那么一次可能用到的数据在一个或者多个芯片上。
- 读写控制线：可以使用一根或者两个线来表示

#### 2、片选线的作用

![半导体存储芯片片选线](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%89%87%E9%80%89%E7%BA%BF.png?raw=true)

- 上图展示了一个使用片选线的demo
- 每个芯片16K x 1bit，当计算机需要64K x 8bit时需要32个芯片来实现。
- 8个芯片串行，用之前大楼的概念来看，就是整个楼有2^16个房间，每个房间8个床位，但是注意这8个床位其实是跨房间的（或者说是跨楼的）。如果要住8个人（8bit数据），那么并不是全住在第一个房间，而是住在8个楼（一组串行芯片）的编号相同房间中编号相同的床位上（图中每个房间其实只有一个床位）。

#### 3、译码驱动

- 地址总线传到存储器的地址需要进行译码，然后才能得到在存储器对应的地址。

##### 线选法

![线选法译码驱动](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E7%BA%BF%E9%80%89%E6%B3%95%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8.png?raw=true)

- 线选法图中有4根地址线，因此存储单元有 2^4 = 16个，对应字线0-15。
- 根据4根线上的数据得到具体的字线后，字线上的数据读写到MDR。
- 弊端是如果想要一个1M*8大小的存储器，那么地址线需要20条，而字线需要1M条，对于芯片来说很难。

##### 重合法

![重合法译码驱动](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E9%87%8D%E5%90%88%E6%B3%95%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8.png?raw=true)

- 相当于笛卡尔坐标系
- 10条地址线可以表达出 32 * 32个位置，每个位置是1bit
- 与线选法比较，1M*8的空间 = 2^20 * 2^3 = 2^23bit , 用重合法可以做 2^12 * 2^11 这样一个矩阵，也就是 4k + 2k = 6k条字线。
- 最初看到这里的时候有个疑惑，就是根据重合法每次只能拿到一个bit，但是看到后面的Intel 2114 RAM矩阵后就知道了如何使用重合法一次获得多个bit。

### 三、随机存取机器（RAM）→ 内存

#### 1、静态RAM(SRAM)

##### 保存0和1的原理
- 双稳态触发器

##### 基本单元电路如何构成

![静态RAM基本电路](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF.png?raw=true)


##### 静态RAM芯片如何读写

![静态RAM基本电路读操作](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF%E8%AF%BB%E6%93%8D%E4%BD%9C.png?raw=true)

![静态RAM基本电路写操作](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF%E5%86%99%E6%93%8D%E4%BD%9C.png?raw=true)


##### Intel 2114 RAM 矩阵

![Inter2114 读](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/Inter2114%20%E8%AF%BB.png?raw=true)

- 上图很好的解释了在使用重合法时如何一次读取多个bit数据。
- 行地址译码6位，所以范围是0-63，也就是说字线有64条。 列地址译码有4位，也就是说有16个。
- 字长为64bit，将64分成4组，每组是16bit（对应列地址位数）。
- 当行地址是0，列地址也是0时，其实取的是四组中第0位的数据，这样就实现了重合法一次取出多位。
- 写操作基本相同。

#### 2、动态RAM(DRAM)

##### 保存0和1的原理
- 电容，充电是1，没充电是0。

##### 基本单元电路如何构成

![动态RAM基本单元电路](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8A%A8%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF.png?raw=true)
- 左边3管动态RAM，右边单管。

##### 动态RAM芯片如何读写

![Inter1103 读](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/Inter1103%20%E8%AF%BB.png?raw=true)

- 行地址译码器这里参加译码的不止是地址还有读写选择线。
- 三角形是刷新放大器。作用：电容存储电荷的原理，电容会漏掉，经过一段时间电容上信号消失。刷新放大器对电容中保持的信息进行重现。

##### 动态RAM刷新
- 只和行地址有关，与列地址无关。一次刷新刷的就是一行所有的基本单元电路。

##### 刷新方式

- **集中式**

![动态RAM集中刷新](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8A%A8%E6%80%81RAM%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0.png?raw=true)

- 可以看到2毫秒按照存取周期0.5微秒分成了4000份，其中128个周期是用来刷新的。
- 在死区时间内CPU和IO设备如果想访问动态RAM只能等待。

- **分散式**

![动态RAM分散刷新](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8A%A8%E6%80%81RAM%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0.png?raw=true)

- 本来每个存取周期是0.5微秒，但是为了刷新又加了0.5，导致一个存取周期变为了1微秒。
- 没有了死区
- 和集中式比较，2毫秒内每行要刷新15.6次，存在过度刷新的问题。

- **异步式**

![动态RAM异步刷新](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8A%A8%E6%80%81RAM%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0.png?raw=true)

- 在15.6微秒中可以认为是集中式，在2毫秒的周期内看是分散式的。
- 确实在安排好的情况下不会出现死区。


#### 3、SRAM和DRAM的比较

![SRAM和DRAM的比较](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/SRAM%E5%92%8CDRAM%E7%9A%84%E6%AF%94%E8%BE%83.png?raw=true)

- 注意引脚数，DRAM行地址和列地址可以分开传输，所以少。但是这样在速度上慢。
- 而且DRAM电容充放电比较慢，所以读取速度慢。


### 四、只读存储器 ROM
- 基本都是电子元器件的内容

![PROM](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/PROM.png?raw=true)

![EPROM](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/EPROM.png?raw=true)

### 五、存储器与CPU的连接

#### 存储器扩展

- 位扩展

![存储器位扩展](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%8D%E6%89%A9%E5%B1%95.png?raw=true) 

- 位扩展利用两个芯片的数据线放到数据总线上不同的线上

- 字扩展

![存储器位扩展](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%AD%98%E5%82%A8%E5%99%A8%E5%AD%97%E6%89%A9%E5%B1%95.png?raw=true) 

- 利用多出来的一条地址线作为片选线，从而实现两个芯片逻辑上的串联。扩展地址线长度。

- 位和字扩展

![存储器字和位扩展](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%AD%98%E5%82%A8%E5%99%A8%E5%AD%97%E5%92%8C%E4%BD%8D%E6%89%A9%E5%B1%95.png?raw=true)

- 多出两根地址线，形成一个范围从0-3的可变数字。
- 将8个芯片分成4组，刚好对应上面的数字。通过地址线A11 A10加不同的电来实现片选译码。
- 对于每组2个芯片正常的位扩展。


##### 一个连接的练习

![CPU与存储器的连接](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/CPU%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%BF%9E%E6%8E%A5.png?raw=true)

- 开始学位和字的扩展时觉得很奇怪，但是当会后讲到一个如何设计CPU与存储芯片连接的题时就明白了一个核心：因为CPU的地址线和数据线数量与芯片的不同，因此需要进行位的扩展来适应CPU的数据线，需要合理的设计地址线来做片选译码和地址译码。
- 通常地址线的高位做片选译码，低位做地址译码。


### 六、提高访存速度的措施 

- 高位交叉，高位交叉中很大概率是M0被频繁访问，而后面的不会。因为数据或者指令总是按照内存地址的顺序被使用。

![高位交叉](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89.png?raw=true)

- 低位交叉

![低位交叉](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89.png?raw=true)

- 这样的地址布局可以使得M0-3这四个存储体可以依次的被CPU使用。如果报错的是代码指令，就是先调用M0的0000位置，然后是M1的0000位置，依次使用。

![低位交叉使用的时间](https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E9%97%B4.png?raw=true)

- 低位交叉被并发的访问，将一个存储周期分成4份。


### 延展阅读

#### 1、关于按字寻址和按字节寻址的理解

> 设有一个1MB容量的存储器，字长32位，问：按字节编址，字编址的寻址范围以及各自的寻址范围大小? 
>
> 如果按字节编址，则 

    1MB = 2^20B 
    
    1字节=1B=8bit 

    2^20B/1B = 2^20 

> 地址范围为0~(2^20)-1,也就是说需要二十根地址线才能完成对1MB空间的编码，所以地址寄存器为20位,寻址范围大小为 2^20 = 1M
>
> 如果按字编址，则

    1MB=2^20B

    1字=32bit=4B

    2^20B/4B = 2^18   

> 地址范围为0~2^18-1，也就是说我们至少要用18根地址线才能完成对1MB空间的编码。因此按字编址的寻址范围是 2^18
>
> 以上题目注意几点：
>
> 1.区分寻址空间与寻址范围两个不同的概念，寻址范围仅仅是一个数字范围，不带有单位。而寻址范围的大小很明显是一个数，指寻址区间的大小。而寻址空间指能够寻址最大容量，单位一般用MB、B来表示；本题中寻址范围为0~(2^20)-1,寻址空间为1MB。
>
> 2.按字节寻址，指的是存储空间的最小编址单位是字节，按字编址，是指存储空间的最小编址单位是字，以上题为例，总的存储器容量是一定的，按字编址和按字节编址所需要的编码数量是不同的，按字编址由于编址单位比较大（1字=32bit=4B），从而编码较少，而按字节编址由于编码单位较小（1字节=1B=8bit），从而编码较多。
>
> 3.区别M和MB。

    M为数量单位。1024=1K，1024K=1M

    MB指容量大小。1024B=1KB，1024KB=1MB.

### 参考

- https://blog.csdn.net/lishuhuakai/article/details/8934540