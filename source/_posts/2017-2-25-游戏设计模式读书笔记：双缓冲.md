---
layout: post
title:  "游戏设计模式读书笔记：双缓冲"
date:   2017-2-25 16:43:13 +0800
thumbnail: "img/home-bg-o.jpg"
categories: 
- 游戏开发
tags:
- 游戏设计模式
---

## 第三篇：序列模型
- 双缓冲模式算是书中第三篇：序列模型中的一个，它与游戏循环和更新方法组成了第三篇。后两者可以说是在我做Unity中最常用到的，而且也是游戏引擎本身已经实现了的。谨以[下文](http://gpp.tkchu.me/sequencing-patterns.html)来说明下序列模型部分的重要性。

> 电子游戏之所有有趣，很大程度上归功于它们会将我们带到别的地方。 几分钟后（或者，诚实点，可能会更长），我们活在一个虚拟的世界。 创造那样的世界是游戏程序员至上的欢愉。

>大多数游戏世界都有的特性是时间——虚构世界以其特定的节奏运行。 作为世界的架构师，我们必须发明时间，制造推动游戏时间运作的齿轮。

>这本篇的模式是建构这些的工具。 游戏循环是时钟的中心轴。 对象通过更新方法来聆听时钟的滴答声。 我们可以用双缓冲模式存储快照来隐藏计算机的顺序执行，这样看起来世界可以进行同步更新。

<!--more-->

## 双缓冲
#### 一个典型的例子
- 这个例子非常经典，就是渲染时候的双缓冲。只有当一帧的色值数据完全计算出来后，才能在屏幕上展示出来，如果在计算的同时就开始渲染，那么屏幕只会出现一部分的色彩。所以我们在屏幕看到的色彩值其实往往是GPU算出的上一帧的数据。

#### 使用场景
> 我们需要维护一些被逐步改变着的状态量。
> 
> 同个状态可能会在其被修改的同时被访问到。
> 
> 我们希望避免访问状态的代码能看到具体的工作过程。
> 
> 我们希望能够读取状态但不希望等到写入操作的完成。

#### 我对双缓冲的理解
- 说白了，双缓冲是为了维护完整性。它展示给外界的永远是一个完整的，已经准备好被使用的内容。在其内部，有一个缓冲是用于写入数据的，写入的过程可能是缓慢的，但是没关系，另一个缓冲已经做好了被使用的准备，外界读取的是这个已经写好的缓冲。
- 当写入完成时，两个缓冲互换，刚刚写完的这个缓冲变为准备被读取的一个，而被读取的缓冲开始作为写入缓冲使用。

#### 设计决策

- 缓冲区如何交互？
  - 在文中作者使用的是C++，因此交换只不过是一个指针重定向的过程。
  - 如果不能指针重定向，就要考虑数据拷贝了。
  - C#中一个集合对象表现出来的也是一个指针（引用），可以直接做重定向。

- 缓冲的粒度
  - 书中提到两个粒度，一个是缓冲区是单个整体，也就是渲染的时候一个图像的内容就在一个缓冲区中。
  - 另一种情况就是多个对象中都存在一个缓冲数据。




 